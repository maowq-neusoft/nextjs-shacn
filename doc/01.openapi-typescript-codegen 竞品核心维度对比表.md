# openapi-typescript-codegen 竞品核心维度对比表
| 工具名称               | 代码质量（类型精准/简洁性/可维护性） | 受欢迎程度（GitHub 星标/活跃度）       | 主要使用场景                                  | 核心优点                                      | 核心缺点                                      |
|------------------------|--------------------------------------|----------------------------------------|-----------------------------------------------|-----------------------------------------------|-----------------------------------------------|
| openapi-typescript-codegen | ✅ 类型与 OpenAPI 1:1 映射，代码结构清晰（核心+业务分层），冗余少 | ⭐ 3.2k+，更新稳定（月均3-5次提交）     | 前端（React/Vue/Next.js）、Node.js 后端，需多客户端适配的 TypeScript 项目 | 1. 多客户端支持（12+种，如 axios/fetch/react-query）；2. 零侵入集成，生成代码开箱即用；3. 适配前后端双场景 | 1. 高阶功能（如架构验证、分页）缺失；2. 新版注释参数简化，灵活性下降 |
| openapi-generator       | ✅ 类型覆盖全，支持复杂规范（如多态/鉴别器），但 TypeScript 代码冗余度高 | ⭐ 18.6k+，超活跃（日均3-5次提交）      | 多语言协作项目、需同时生成客户端/服务端/文档的大型企业级项目 | 1. 支持30+编程语言，全能型工具；2. 模板自定义能力极强；3. 兼容 OpenAPI 全规范 | 1. 需 Java 运行环境，上手成本高；2. TypeScript 生态适配不如专注型工具；3. 生成代码冗余 |
| orval                  | ✅ 类型精准，深度适配前端状态管理，代码与 react-query/msw 无缝整合 | ⭐ 4.5k+，高活跃（日均1-2次提交）       | React/Vue 前端项目，需请求缓存+Mock 服务+状态管理的开发场景 | 1. 深度整合 react-query/vue-query/msw；2. 自动生成 Mock 数据和请求 Hooks；3. 支持热更新 | 1. 仅聚焦前端，不支持 Node.js/后端场景；2. 客户端选择单一（仅 fetch/axios） |
| swagger-typescript-api  | ✅ 注释完整，类型映射精准，但生成代码冗余注释较多 | ⭐ 3.8k+，中高活跃（月均5-8次提交）     | 依赖 Swagger 2.0 旧规范的存量项目，对接口注释要求高的场景 | 1. 对 Swagger 旧版本兼容性好；2. 注释生成完整（字段/接口/错误说明）；3. 支持自定义模板 | 1. 生成代码体积较大；2. 客户端支持较少（仅 axios/fetch）；3. 框架适配性弱 |
| oazapfts               | ✅ 类型处理精准（支持带鉴别器的联合类型），代码极简轻量 | ⭐ 1.7k+，中低活跃（月均2-3次提交）     | 轻量前端项目，仅需类型定义+基础请求函数的场景 | 1. 类型映射更精准（复杂类型支持好）；2. 代码轻量，打包体积小；3. 无额外依赖 | 1. 功能单一（无 Mock/缓存/框架适配）；2. 树摇支持有限；3. 进阶功能缺失 |
| speakeasy              | ✅ 类型+架构双重验证（基于 zod），代码健壮性高 | ⭐ 2.1k+，中活跃（月均3-4次提交）       | 企业级 SDK 开发、需全环境兼容+完善文档的复杂 API 场景 | 1. 基于 zod 做架构验证，减少运行时错误；2. 兼容浏览器/Node.js/deno 等全环境；3. 自动生成文档和示例 | 1. 学习成本高（依赖 zod 生态）；2. 客户端选择少；3. 生成代码稍复杂 |
| openapi-typescript     | ✅ 纯类型定义，无冗余代码，类型精准度拉满 | ⭐ 12.3k+，超活跃（日均2-3次提交）      | 需自主控制请求逻辑，仅需类型约束的定制化场景 | 1. 体积极小（仅输出类型文件）；2. 类型定义精准，支持 OpenAPI 3.x 全规范；3. 与任意请求库兼容 | 1. 不生成请求函数，需二次封装；2. 无框架/客户端适配，二次开发成本高 |

### 核心选择建议
1. 若需 **前后端通吃+多客户端适配**：选 openapi-typescript-codegen；
2. 若需 **多语言协作+企业级定制**：选 openapi-generator；
3. 若需 **前端全链路（请求+Mock+缓存）**：选 orval；
4. 若需 **旧项目兼容+注释完整**：选 swagger-typescript-api；
5. 若需 **轻量极简+精准类型**：选 oazapfts；
6. 若需 **自主控制请求逻辑+纯类型约束**：选 openapi-typescript；
7. 若需 **企业级 SDK+架构验证**：选 speakeasy。